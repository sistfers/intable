/*
  JOIN : 여러개의 테이블에서 원하는 자료를 조회하기 위한 작업.
  
  조인연산 = 커티션 곱 + 선택 연산
*/

-- 조인을 시킬때는 무조건 왼쪽에 있는게 중심이된다. 두 테이블에 둘다있는 컬럼은 A.등으로 명시를 확실히.
-- 가장 기본적인 조인
SELECT A.EMPLOYEE_ID, FIRST_NAME, A.DEPARTMENT_ID, D.DEPARTMENT_ID,
    DEPARTMENT_NAME, D.MANAGER_ID
FROM Employees A INNER JOIN DEPARTMENTS D
ON A.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- 이것도 join. 그런데 departMentid 10부터 모든정보 쭈르륵, 20부터 모든정보 쭈르륵 가져와서 거의 모든것에 대입.
-- 무한대에 가가운 조인이라 쓸일이 거의없다.
SELECT employee_id, FIRST_NAME, A.DEPARTMENT_ID, D.DEPARTMENT_ID, DEPARTMENT_NAME, D.MANAGER_ID
FROM EMPLOYEES A, DEPARTMENTS D;

-- INNER 조인. (교집합) INNER JOIN 이렇게 쓸수도있지만 WHERE절로 저렇게 조건줄수도잇다.
-- 106개만 나온이유? EMPLOYEEs 의 킹은 MANAGER_ID가 없어서 교집합인 106만 나온것.
SELECT employee_id, FIRST_NAME, A.DEPARTMENT_ID, D.DEPARTMENT_ID, DEPARTMENT_NAME, D.MANAGER_ID
FROM EMPLOYEES A, DEPARTMENTS D
WHERE A.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- ANSI 테이블 3개 JOIN    EMPLOYEES의 JOB_ID, DEPARTMENT_ID 로 각자 조인한것.
SELECT EMPLOYEE_ID, FIRST_NAME, A.DEPARTMENT_ID, C.JOB_ID, B.DEPARTMENT_NAME, C.JOB_TITLE
FROM EMPLOYEES A INNER JOIN DEPARTMENTS B
  ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
  JOIN JOBS C ON A.JOB_ID = C.JOB_ID;

-- ORACLE 스타일 테이블 3개 JOIN
SELECT EMPLOYEE_ID, FIRST_NAME, A.DEPARTMENT_ID, C.JOB_ID, B.DEPARTMENT_NAME, C.JOB_TITLE 
FROM EMPLOYEES A, DEPARTMENTS B, JOBS C
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
  AND A.JOB_ID = C.JOB_ID;
  
-- OUT JOIN (LEFT, RIGHT)
-- LEFT (자동 OUTER로 됌) EMPLOYEES 테이블이 중심이된다. 여기에 해당하는 값만 표현이됌.
-- DEPARTMENT_NAME이 NULL인 킹도 표현됌.
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, B.DEPARTMENT_NAME
FROM EMPLOYEES A LEFT OUTER JOIN DEPARTMENTS B
  ON A.DEPARTMENT_ID = B.DEPARTMENT_ID;

-- + 기호를 붙인 반대쪽이 중심이된다. 위와 마찬가지로 LEFT OUTER 조인
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, B.DEPARTMENT_NAME
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID(+);

-- 차집합  B를 제외한 A만 가져온것. (교집합 된 부분이 106개, king만 포함안됐엇는데 차집합으로 가져오니 king만 표출되는것)
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, B.DEPARTMENT_NAME
FROM EMPLOYEES A LEFT OUTER JOIN DEPARTMENTS B
  ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
WHERE B.DEPARTMENT_ID IS NULL; 

SELECT A.EMPLOYEE_ID, A.FIRST_NAME, B.DEPARTMENT_NAME
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID(+)
  AND B.DEPARTMENT_ID IS NULL;
  
-- RIGTH DEPARTMENTS 가 중심이된다. 그래서 106까지는 매치가 된 부분이 나오지만
-- 그 이후의 값에는 교집합된 부분이 없으므로 B의 결과가 표출되는대신 A값에선 NULL만 줄창뜨는것.
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, B.DEPARTMENT_NAME
FROM EMPLOYEES A RIGHT OUTER JOIN DEPARTMENTS B
  ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
  ORDER BY A.EMPLOYEE_ID;

-- A에 대한 차집합. 공통부분 제외 B만 가져온다. 그래서 A부분에 해당하는 값은 전부 null이나오는것. (B에없으니까)
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, B.DEPARTMENT_NAME
FROM EMPLOYEES A RIGHT OUTER JOIN DEPARTMENTS B
  ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
WHERE A.DEPARTMENT_ID IS NULL;

SELECT A.EMPLOYEE_ID, A.FIRST_NAME, B.DEPARTMENT_NAME
FROM EMPLOYEES A, DEPARTMENTS B
  WHERE A.DEPARTMENT_ID(+) = B.DEPARTMENT_ID -- +의 반대쪽이 중심이므로 이번엔 B의 데이터를 다 가져오는것.
  AND A.DEPARTMENT_ID IS NULL; -- A부분을 NULL로 함으로써 A의 차집합(순수B - 교집합)만 나온다.
  
  
-- Steven King의 부서명을 출력
SELECT e.FIRST_NAME, e.LAST_NAME, d.DEPARTMENT_NAME
FROM EMPLOYEES e LEFT JOIN DEPARTMENTS d
 ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
WHERE e.FIRST_NAME = 'Steven' AND e.LAST_NAME = 'King';

-- IT부서에서 근무하는 사람들을 출력  OUTER => 중심이 된 테이블쪽. (A가 B(중심)가 가지고있는값을 안가지고있어도 표출이되며 NULL로 떠버린다)
-- 이 문제로는 OUTER안해도 상관 x
SELECT e.FIRST_NAME, e.LAST_NAME, d.DEPARTMENT_NAME
FROM EMPLOYEES e JOIN DEPARTMENTS d
  ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
WHERE d.DEPARTMENT_NAME = 'IT';

SELECT e.FIRST_NAME, e.LAST_NAME, d.DEPARTMENT_NAME
FROM EMPLOYEES e, DEPARTMENTS d
WHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID AND d.DEPARTMENT_NAME = 'IT';

-- INNER Join 복습 106개. 교집합이므로 106개만나옴.(NULL값 표현x)
SELECT COUNT(*)
FROM EMPLOYEES A JOIN departments D
  ON A.DEPARTMENT_ID = D.DEPARTMENT_ID;
  
-- OUTER , 107나옴. A기반으로 나온다.
SELECT COUNT(*)
FROM EMPLOYEES A LEFT JOIN departments D
  ON A.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT A.EMPLOYEE_ID, A.EMPLOYEE_ID, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES A, DEPARTMENTS D
WHERE A.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
ORDER BY D.DEPARTMENT_NAME NULLS FIRST;

-- FULL OUTER JOIN 합집합 .
SELECT A.EMPLOYEE_ID, A.EMPLOYEE_ID, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES A FULL OUTER JOIN DEPARTMENTS D
ON A.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- Oracle 문법으로 하려면 UNION 해야함. 두개를 이어준다.
SELECT A.EMPLOYEE_ID, A.EMPLOYEE_ID, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES A, DEPARTMENTS D
WHERE A.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
UNION
SELECT A.EMPLOYEE_ID, A.EMPLOYEE_ID, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES A, DEPARTMENTS D
WHERE A.DEPARTMENT_ID(+) = D.DEPARTMENT_ID;

-- SELF JOIN (아무것도 안적으면 왼쪽이 기반.
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.MANAGER_ID, -- MANAGER_ID와 EMPLOYEE ID가 조인되어있다.
       B.EMPLOYEE_ID, B.FIRST_NAME, B.MANAGER_ID -- (같은값) -> 즉, 해당사원에 대한 매니저의 번호와 이름을 알수있다.
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID = B.EMPLOYEE_ID;

-- 계층 구조
-- CONNECT BY(계층구조) PRIOR(계층구조 설정)
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.MANAGER_ID
FROM EMPLOYEES A
START WITH A.MANAGER_ID IS NOT NULL
CONNECT BY PRIOR A.MANAGER_ID = A.EMPLOYEE_ID;  -- 상향식 (매니저아이디가 먼저니까 높은사람이 위에서부터 나타나고, 상사를 찾는식으로 올라감.)
--CONNECT BY A.MANAGER_ID = PRIOR A.EMPLOYEE_ID; -- 하향식 (가장낮은 사원부터 시작해서 상사를 찾는식으로 내려간다.)
